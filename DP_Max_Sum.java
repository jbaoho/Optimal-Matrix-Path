import java.util.Arrays;
import java.util.Scanner;
import java.util.Stack;

public class DP_Max_Sum {

    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);
        System.out.println("How many rows would you like your matrix to have?");
        int rows = scan.nextInt();
        System.out.println("How many columns would you like your matrix to have?");
        int cols = scan.nextInt();

        // initialize the 2D array representing the Lonely Mountain vaults
        int[][] A = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                System.out.printf("Please enter the integer you would like for row %d column %d of your matrix:", (i + 1), (j + 1));
                A[i][j] = scan.nextInt();
            }
        }

        // Determine and print the best path
        Stack<Integer> path = findPath(A);
        int a = 1, max = path.pop();
        System.out.printf("The optimal path from row %d to row %d is given by:\n", 1, rows);
        while (!path.isEmpty()) {
            System.out.printf("Row %d Column %d\n", a++, path.pop());
        }
        System.out.printf("The maximum sum of generated by this path is %d.\n", max);

    }

    public static Stack<Integer> findPath(int[][] a) {

        int numRows = a.length, numCols = a[0].length;

        // initialize a 2D array to keep track of (memorize) the most optimal penultimate vault
        int[][] path = new int[numRows][numCols];

        // initialize a copy of a[][] to work with such that a[][] is not altered through this function
        int[][] vaults = new int[numRows][numCols];
        for (int i = 0; i < numRows; i++) {
            vaults[i] = Arrays.copyOf(a[i], numCols);
        }

        for (int r = 1; r < numRows; r++) {
            for (int c = 0; c < numCols; c++) {

                // for each element vault in a row past the starting row
                // determine which vault directly below it gives the most value
                int current = vaults[r][c];

                // set the current best path as directly below
                int max = current + vaults[r - 1][c];
                int penultimate = c;

                // check the vault below and to the left
                if (c != 0) {
                    if (vaults[r - 1][c - 1] + current > max) {
                        penultimate = c - 1;
                        max = vaults[r - 1][c - 1] + current;
                    }
                }

                // check the vault below and to the right
                if (c != numCols - 1) {
                    if (vaults[r - 1][c + 1] + current > max) {
                        penultimate = c + 1;
                        max = vaults[r - 1][c + 1] + current;
                    }
                }

                // update the best path matrix and the values of vault for the next iteration
                path[r][c] = penultimate;
                vaults[r][c] = max;
            }
        }

        // once all the values are computed,
        // look at the final row to determine the maximum sum
        int max = vaults[numRows - 1][0];
        int finalVault = 0;
        for (int j = 1; j < numCols; j++) {
            if (vaults[numRows - 1][j] > max) {
                max = vaults[numRows - 1][j];
                finalVault = j;
            }
        }
        // create an iterable to hold the path
        Stack<Integer> bestPath = new Stack<>();
        bestPath.push(finalVault);

        int c = finalVault;
        for (int i = numRows - 1; i >= 1; i--) {
            c = path[i][c];
            bestPath.push(c);
        }
        // push the maximum value onto the stack for display
        bestPath.push(max);

        return bestPath;
    }

}
